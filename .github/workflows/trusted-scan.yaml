name: Secret Scanner

on:
  workflow_call:
    inputs:
      changed_files:
        required: true
        type: string
    secrets:
      AIAPIKEY:
        required: true
      AIAPIURL:
        required: true

permissions:
  contents: read
  security-events: write

jobs:
  scan:
    runs-on: ubuntu-latest
    outputs:
      leak_status: ${{ steps.set-output.outputs.leak_status }}

    steps:
    - name: Checkout PR source
      uses: actions/checkout@v3
      with:
        ref: ${{ github.event.pull_request.head.sha }}

    - name: Write file list
      run: |
        echo "${{ inputs.changed_files }}" | tr ',' '\n' > file_list.txt
        echo "Files to be scanned:"
        cat file_list.txt

    - name: Ensure .leakignore exists
      run: |
        if [ ! -f .leakignore ]; then
          echo ".leakignore not found in PR; trying base branch..."
          git fetch origin ${{ github.event.pull_request.base.ref }}
          if git ls-tree -r origin/${{ github.event.pull_request.base.ref }} --name-only | grep -q '^.leakignore$'; then
            git show origin/${{ github.event.pull_request.base.ref }}:.leakignore > .leakignore
            echo "Loaded .leakignore from base branch"
          else
            echo ".leakignore not found in base branch; downloading from fallback URL"
            curl -sfL https://raw.githubusercontent.com/sdn-sense/default-actions/refs/heads/master/leakignore -o .leakignore || echo "" > .leakignore
          fi
        fi

    - name: Load .leakignore patterns
      run: |
        IGNORE=$(jq -Rs . < .leakignore)
        echo "IGNORE=$IGNORE" >> $GITHUB_ENV

    - name: Analyze each file
      env:
        AIAPIKEY: ${{ secrets.AIAPIKEY }}
        AIAPIURL: ${{ secrets.AIAPIURL }}
        IGNORE: ${{ env.IGNORE }}
      run: |
        set -euo pipefail
        mkdir -p leaks

        LEAK_FILES=()
        while IFS= read -r FILE; do
          [ -f "$FILE" ] || continue
          echo "Scanning: $FILE"

          CONTENT=$(jq -Rs . < "$FILE")
          PAYLOAD=$(jq -n \
            --arg model "openai/gpt-4o-mini" \
            --arg ignore "$IGNORE" \
            --arg file "$FILE" \
            --arg content "$CONTENT" \
            '{
              model: $model,
              temperature: 0.2,
              messages: [
                {
                  role: "system",
                  content: "You are a security reviewer. You are given one file. Return a number from 0 to 100 representing the likelihood that a secret (e.g., password, API key, token, credential) was leaked. Ignore values clearly matching the .leakignore list. If the score is over 50, briefly explain. Otherwise, return just the number."
                },
                {
                  role: "user",
                  content: "Here is the .leakignore list:\n\($ignore)\n\nAnd here is the file (\($file)) content:\n\($content)"
                }
              ]
            }')

          echo "$PAYLOAD" > payload.json
          if ! jq . payload.json > /dev/null; then
            echo "Malformed JSON for $FILE"
            continue
          fi

          if ! curl -sf "$AIAPIURL" \
            -H "Authorization: Bearer $AIAPIKEY" \
            -H "Content-Type: application/json" \
            -d @payload.json > response.json; then
              echo "curl failed for $FILE"
              continue
          fi

          RESPONSE=$(jq -r '.choices[0].message.content' response.json)
          SCORE=$(echo "$RESPONSE" | grep -o '[0-9]\+' | head -n1)

          if [ "$SCORE" -ge 50 ]; then
            echo "$FILE" >> leaks/leak_files.txt
            echo "$RESPONSE" > leaks/"$(echo "$FILE" | sed 's/\//_/g')".expl
            LEAK_FILES+=("$FILE")
            echo "Secret risk in file: $FILE (score: $SCORE)"
          fi
        done < file_list.txt

    - name: Save leak status
      id: set-output
      run: |
        if [ -s leaks/leak_files.txt ]; then
          echo "leak_status=found" >> $GITHUB_OUTPUT
        else
          echo "leak_status=clean" >> $GITHUB_OUTPUT
        fi

    - name: Upload leak artifacts
      if: always()
      uses: actions/upload-artifact@v3
      with:
        name: leak-files
        path: leaks/

  report-leaks:
    runs-on: ubuntu-latest
    needs: scan
    if: needs.scan.outputs.leak_status == 'found'

    steps:
    - name: Checkout repo
      uses: actions/checkout@v3

    - name: Download leaked files
      uses: actions/download-artifact@v3
      with:
        name: leak-files
        path: leaks

    - name: Generate SARIF report
      run: |
        mkdir -p results
        echo '{
          "version": "2.1.0",
          "runs": [{
            "tool": {
              "driver": {
                "name": "LLM Secret Scanner",
                "rules": [{
                  "id": "secret-leak",
                  "name": "Potential Secret Detected",
                  "shortDescription": { "text": "Secret detected by AI scan" },
                  "fullDescription": { "text": "A file was flagged as potentially containing a secret." },
                  "defaultConfiguration": { "level": "error" }
                }]
              }
            },
            "results": [' > results/results.sarif

        FIRST=1
        while IFS= read -r FILE; do
          F_ESC=$(echo "$FILE" | sed 's/\//_/g')
          EXPL=$(jq -Rs . < leaks/"$F_ESC".expl)

          [ $FIRST -eq 0 ] && echo "," >> results/results.sarif
          FIRST=0

          echo "{
            \"ruleId\": \"secret-leak\",
            \"level\": \"error\",
            \"message\": { \"text\": $EXPL },
            \"locations\": [{
              \"physicalLocation\": {
                \"artifactLocation\": { \"uri\": \"$FILE\" },
                \"region\": { \"startLine\": 1 }
              }
            }]
          }" >> results/results.sarif
        done < leaks/leak_files.txt

        echo "] }] }" >> results/results.sarif

    - name: Upload SARIF to GitHub Security tab
      uses: github/codeql-action/upload-sarif@v2
      with:
        sarif_file: results/results.sarif